"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const _ = require("lodash");
const InlineFlagManager_1 = require("./InlineFlagManager");
/**
Beautifier
*/
class Unibeautify {
    constructor() {
        /**
      
        */
        this.options = {};
        /**
      
        */
        this.languages = [];
        /**
      
        */
        this.beautifiers = [];
    }
    /**
     * Get loaded languages which have a loaded beautifier supporting the given option
     */
    getLanguagesSupportingOption(optionName) {
        return this.supportedLanguages.filter(language => this.beautifiers.findIndex(beautifier => this.doesBeautifierSupportOptionForLanguage({
            beautifier,
            language,
            optionName
        })) !== -1);
    }
    /**
     * Get options supported for language and all loaded beautifiers
     */
    getOptionsSupportedForLanguage(language) {
        return this.beautifiers.reduce((options, beautifier) => (Object.assign({}, options, this.getOptionsSupportedByBeautifierForLanguage({
            beautifier,
            language
        }))), {});
    }
    /**
     * Get options supported by beautifier for a language.
     */
    getOptionsSupportedByBeautifierForLanguage({ beautifier, language }) {
        const keys = optionKeys(beautifier, language);
        const allOptions = this.options;
        return keys.reduce((options, key) => {
            const option = allOptions[key];
            if (!option) {
                return options;
            }
            return Object.assign({}, options, { [key]: option });
        }, {});
    }
    /**
     * Get all loaded languages which have at least one supporting beautifier.
     */
    get supportedLanguages() {
        return this.getLoadedLanguages().filter(language => Boolean(this.getBeautifierForLanguage(language)));
    }
    /**
    Beautify code
    */
    beautify(data) {
        const lang = this.getLanguage(data);
        if (lang == null) {
            return Promise.reject(new Error("Cannot find language."));
        }
        const langOptions = Unibeautify.getOptionsForLanguage(lang, data.options);
        const { selectedBeautifiers, missingBeautifierName } = this.beautifiersForLanguageAndOptions(lang, langOptions);
        if (selectedBeautifiers.length === 0) {
            return Promise.reject(new Error(`Beautifiers not found for Language: ${lang.name}`));
        }
        if (missingBeautifierName) {
            return Promise.reject(new Error(`Beautifier not found: ${missingBeautifierName}`));
        }
        return this.beautifyWithBeautifiers({
            beautifiers: selectedBeautifiers,
            fileExtension: data.fileExtension,
            langOptions,
            language: lang,
            projectPath: data.projectPath,
            text: data.text
        });
    }
    getLanguage(data) {
        const langs = this.findLanguages({
            atomGrammar: data.atomGrammar,
            extension: data.fileExtension,
            name: data.languageName,
            sublimeSyntax: data.sublimeSyntax
        });
        return langs.length > 0 ? langs[0] : null;
    }
    beautifiersForLanguageAndOptions(lang, langOptions) {
        const allBeautifiers = this.getBeautifiersForLanguage(lang);
        const beautifierNames = langOptions.beautifiers || [];
        const selectedBeautifiers = beautifierNames.length > 0
            ? this.beautifiersWithNames(beautifierNames, allBeautifiers)
            : allBeautifiers;
        const missingBeautifierName = selectedBeautifiers
            .map((curr, index) => (curr ? undefined : beautifierNames[index]))
            .find(curr => !!curr);
        return {
            missingBeautifierName,
            selectedBeautifiers
        };
    }
    beautifiersWithNames(names, beautifiers) {
        const beautifiersByName = beautifiers.reduce((index, current) => {
            index[current.name] = current;
            return index;
        }, {});
        return names.map(name => beautifiersByName[name]);
    }
    beautifyWithBeautifiers({ beautifiers, language, langOptions, fileExtension, projectPath, text }) {
        return beautifiers.reduce((promise, beautifier, index) => {
            const options = Unibeautify.getOptionsForBeautifier(beautifier, language, langOptions);
            return promise.then(currentText => {
                return beautifier
                    .beautify({
                    filePath: fileExtension,
                    language: language,
                    options,
                    projectPath: projectPath,
                    Promise,
                    text: currentText
                })
                    .then(newText => {
                    const manager = new InlineFlagManager_1.InlineFlagManager(currentText, newText);
                    return manager.text;
                });
            });
        }, Promise.resolve(text));
    }
    /**
    Find and return the appropriate Languages that match any of the given filter criteria.
    An empty array will be returned if there are no matches.
  
    Precedence:
    - name
    - namespace
    - extension
    - atomGrammar
    - sublimeSyntax
    - vscodeLanguage
    */
    findLanguages(query) {
        const langs = [];
        // Name
        langs.push(_.filter(this.languages, (language) => _.isEqual(language.name, query.name)));
        // Namespace
        langs.push(_.filter(this.languages, (language) => _.isEqual(language.namespace, query.namespace)));
        // Extension
        langs.push(_.filter(this.languages, (language) => _.includes(language.extensions, query.extension)));
        // Atom Grammar
        langs.push(_.filter(this.languages, (language) => _.includes(language.atomGrammars, query.atomGrammar)));
        // Sublime Syntax
        langs.push(_.filter(this.languages, (language) => _.includes(language.sublimeSyntaxes, query.sublimeSyntax)));
        // VSCode Language ID
        langs.push(_.filter(this.languages, (language) => _.includes(language.vscodeLanguages, query.vscodeLanguage)));
        // Return unique array of Languages
        return _.uniq(_.flatten(langs));
    }
    /**
    Get a shallow copy of the languages currently loaded.
    */
    getLoadedLanguages() {
        return this.languages.slice();
    }
    /**
     * Get first loaded beautifier for given language.
     */
    getBeautifierForLanguage(language) {
        return _.find(this.beautifiers, (beautifier) => this.doesBeautifierSupportLanguage(beautifier, language));
    }
    /**
     * Find and return the appropriate Beautifiers for the given Language.
     */
    getBeautifiersForLanguage(language) {
        return _.filter(this.beautifiers, (beautifier) => this.doesBeautifierSupportLanguage(beautifier, language));
    }
    doesBeautifierSupportLanguage(beautifier, language) {
        return beautifier.options.hasOwnProperty(language.name);
    }
    /**
     * Get loaded beautifiers which have a loaded languages supporting the given option
     */
    getBeautifiersSupportingOption(optionName) {
        return this.beautifiers.filter(beautifier => this.languages.findIndex(language => this.doesBeautifierSupportOptionForLanguage({
            beautifier,
            language,
            optionName
        })) !== -1);
    }
    /**
     * Determine whether beautifier supports option for a language
     */
    doesBeautifierSupportOptionForLanguage({ beautifier, language, optionName }) {
        return optionKeys(beautifier, language).indexOf(optionName) !== -1;
    }
    /**
     * Find loaded languages the given beautifier supports.
     */
    getLanguagesForBeautifier(beautifier) {
        const { options } = beautifier;
        return this.languages.filter(lang => options.hasOwnProperty(lang.name));
    }
    /**
     * Get a shallow copy of the options currently loaded.
     */
    get loadedOptions() {
        return Object.assign({}, this.options);
    }
    /**
     * Get a shallow copy of the beautifiers currently loaded.
     */
    get loadedBeautifiers() {
        return this.beautifiers.slice();
    }
    /**
    Extract the Language-specific option values.
    */
    static getOptionsForLanguage(language, options) {
        const { name } = language;
        return options[name] || {};
    }
    /**
    Extract the option values that the Beautifier supports, including applying transformations.
    */
    static getOptionsForBeautifier(beautifier, language, options) {
        const globalOptions = beautifier.options._;
        let beautifierOptions = beautifier.options[language.name];
        // Global options
        if (typeof globalOptions === "object") {
            if (beautifierOptions === true) {
                beautifierOptions = globalOptions;
            }
            else if (typeof beautifierOptions === "object") {
                beautifierOptions = Object.assign({}, globalOptions, beautifierOptions);
            }
        }
        // Transform options
        if (typeof beautifierOptions === "boolean") {
            if (beautifierOptions === true) {
                return options;
            }
            else {
                return {};
            }
        }
        else if (typeof beautifierOptions === "object") {
            const transformedOptions = {};
            Object.keys(beautifierOptions).forEach(fieldKey => {
                const op = beautifierOptions[fieldKey];
                if (typeof op === "string") {
                    transformedOptions[fieldKey] = options[op];
                }
                else if (typeof op === "function") {
                    transformedOptions[fieldKey] = op(options[fieldKey]);
                }
                else if (typeof op === "boolean") {
                    if (op === true) {
                        transformedOptions[fieldKey] = options[fieldKey];
                    }
                }
                else if (_.isArray(op)) {
                    const [fields, fn] = op;
                    const vals = _.map(fields, field => options[field]);
                    const obj = _.zipObject(fields, vals);
                    transformedOptions[fieldKey] = fn(obj);
                }
            });
            return transformedOptions;
        }
        else {
            return options;
        }
    }
    /**
    Load a Beautifier
    */
    loadBeautifier(beautifier) {
        this.beautifiers.push(beautifier);
        return this;
    }
    /**
    Load multiple beautifiers.
    */
    loadBeautifiers(beautifiers) {
        this.beautifiers.push(...beautifiers);
        return this;
    }
    /**
    Load a Language
    */
    loadLanguage(language) {
        this.languages.push(language);
        return this;
    }
    /**
    Load multiple Languages
    */
    loadLanguages(languages) {
        this.languages.push(...languages);
        return this;
    }
    /**
    Load Options
    */
    loadOptions(options) {
        _.merge(this.options, options);
        return this;
    }
}
exports.Unibeautify = Unibeautify;
function optionKeys(beautifier, language) {
    const globalOptions = beautifier.options._;
    let beautifierOptions = beautifier.options[language.name];
    // Global options
    if (typeof globalOptions === "object") {
        if (beautifierOptions === true) {
            beautifierOptions = globalOptions;
        }
        else if (typeof beautifierOptions === "object") {
            beautifierOptions = Object.assign({}, globalOptions, beautifierOptions);
        }
    }
    // Transform options
    if (typeof beautifierOptions === "boolean") {
        return [];
    }
    else if (typeof beautifierOptions === "object") {
        const options = [];
        Object.keys(beautifierOptions).forEach(fieldKey => {
            const op = beautifierOptions[fieldKey];
            if (typeof op === "string") {
                options.push(op);
            }
            else if (isOptionTransformSingleFunction(op)) {
                options.push(fieldKey);
            }
            else if (typeof op === "boolean") {
                if (op === true) {
                    options.push(fieldKey);
                }
            }
            else if (isOptionTransform(op)) {
                options.push(...op[0]);
            }
        });
        return options;
    }
    else {
        return [];
    }
}
exports.optionKeys = optionKeys;
function isOptionTransformSingleFunction(option) {
    return typeof option === "function";
}
function isOptionTransform(option) {
    return Array.isArray(option);
}
//# sourceMappingURL=beautifier.js.map